
- demo create and update
    e = sg.create('PublishEvent', {'code': 'test5', 'project': {'type': 'Project', 'id': 66}}); print e; print sg.find_one('PublishEvent', [('id', 'is', e['id'])], ['code'])

    sg.update('PublishEvent', 10502, {'code': 'test4'}); print sg.find_one('PublishEvent', [('id', 'is', 10502)], ['code'])

- multi_entity is_not None -> True if there is something in there

- remove all global state:
    - Config object to represent the config
    - make_app to make the flask app
    - make_cache to make the schema and cache

- Skip change events that follow a create event.

- split non-indempotent parts of Api3ReadOperation into Api3ReadQuery

- return accurate paging info; currently we are cheating a bit

- redirect Shotgun pages to actual Shotgun

- document the ping/pong feature, OR remove it after adding {'sgcache': true} to
  the info call

- split process up
    - sgcache-server
    - sgcache-scanner
    - sgcache-events

- how to perform rolling schema upgrades?
    1. move event watcher to new schema
    2. perform full scan
    3. restart interval scanner
    4. restart cache with new schema

    - this generally needs services to be independant
    - would also be great if we have a system for sending messages into the
      running services, and having them reload the schema, or adding fields
      live on the fly
        - unix socket in a thread with json messages
    
- get and parse private schema
    s = requests.Session()
    s.cookies['_session_id'] = sg._get_session_token()
    s.get('https://keystone.shotgunstudio.com/page/schema')

- return a fake "name" (as determined by the identifier_column in the 
  private schema) with entities/multi-entities

- sgcache-reprocess --retirement -> reprocess retirement events

- table with log of data updates
- the actual event logs?

- docs:
    ./bin/grep-schema -f schema/basic-filters.txt schema/keystone-full.yaml > schema/keystone-basic.yml
    dev ./bin/dump-data -p 66 -s schema/keystone-basic.yml | tee data.json
    PYTHONPATH=.:$PYTHONPATH bin/update-data -u sqlite:///test.db -s schema/keystone-basic.yml data.json
    SGCACHE_SQLA_URL=sqlite:///test.db PYTHONPATH="$PYTHONPATH:." python -m sgcache.web


    ./bin/dump-data -p 115 -s schema/keystone-basic.yml | tee all.json
    PYTHONPATH=.:$PYTHONPATH bin/update-data -u sqlite:///test.db -s schema/keystone-basic.yml all.json


    SGCACHE_SQLA_URL=sqlite:///test.db PYTHONPATH="$PYTHONPATH:." python -m sgcache.web
    SGCACHE_SQLA_URL=postgres:///sgcache python -m sgcache.web

    ./bin/dump-data -p 66 -s schema/keystone-basic.yml | tee all.json
    ./bin/dump-data -p 115 -s schema/keystone-basic.yml | tee all.json
    PYTHONPATH=.:$PYTHONPATH ./bin/update-data -u postgres:///sgcache -s schema/keystone-basic.yml all.json

- what must be do for `s3_uploads_enabled` in server info?

- URLS could include the real shotgun server:
    >>> sg = Shotgun('http://localhost:8000/next=keystone.shotgunstudio.com/', 'xxx', 'yyy')
    The trailing slash is required for it to not get parsed out.

- Can we instead exist as the http_proxy kwarg?

- listen for schema changes, and use that to invalidate data
